<!DOCTYPE html>
<html>
  <head>
    <title>Mandlebrot</title>
    <style type="text/css">
#mandelbrot-size {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
}
    </style>
  </head>
  <body>

    <div id="mandelbrot-size">
      <canvas id="mandelbrot"></canvas>
    </div>


    <script id="boring-matrix-vertex-shader" type="text/glsl">
attribute vec3 vertex_position;
varying vec2 mandel_coord;

uniform mat4 mv_matrix;
uniform mat4 p_matrix;

void main(void) {
    gl_Position = p_matrix * mv_matrix * vec4(vertex_position, 1.0);
    mandel_coord = vertex_position.xy;
}
    </script>


    <script id="mandelbrot-fragment-shader" type="text/glsl">
precision highp float;

uniform sampler2D color_table;

varying vec2 mandel_coord;

void main(void) {
    float ar = mandel_coord.x;
    float ai = mandel_coord.y;
    int iter=0;
    // This, sadly, does not work, despite it being valid in GLSL ES (see https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf)
    // for (iter=0; iter < 100 && ar*ar + ai*ai > 4.0; iter++) {
    for (int it=0; it<256; it++) {
        iter = it;
        if (ar*ar + ai*ai > 4.0)
             break;
        float r=ar, i=ai;
        ar = r*r - i*i + mandel_coord.x;
        ai = 2.0*r*i + mandel_coord.y;
    }
    gl_FragColor = texture2DProj(color_table, vec3(iter, 0.0, 256.0));
}

    </script>
    <script id="mandelbrot-asmjs" type="text/javascript">

function Mandelbrot(stdlib, foreign, heap) {
    "use asm";

   var heapb = new stdlib.Uint8Array(heap);

    function member(cr, ci) {
        cr = +cr;
        ci = +ci;

        var ar = 0.0, ai=0.0, r=0.0, i=0.0, iter=0, max=100;

        ar = cr, ai=ci;
        for (iter=0;
             (iter>>0 < max>>0) &
             ((ar < 10.0) | (ar > 1.0)) &
             ((ai < 10.0) | (ai > 1.0));
             // ((+stdlib.Math.abs(ar)) < 10.0) &
             // ((+stdlib.Math.abs(ai)) < 10.0);
             iter = (iter>>0) + 1>>0) {
            r=ar, i=ai;
            ar = r*r - i*i + cr;
            ai = 2.0*r*i + ci;
        }
        return +((+(iter>>0))/(+(max>>0)));
    }

    function set_pixel(fb_off, memb) {
        fb_off = fb_off |0;
        memb   = memb   |0;

        heapb[((fb_off<<2)+0)>>0] = 255-memb; // r
        heapb[((fb_off<<2)+1)>>0] = memb & 2 ? memb|0 : (255-memb)|0; // g
        //heapb[((fb_off<<2)+1)>>0] = memb; // g
        heapb[((fb_off<<2)+2)>>0] = memb; // b
        heapb[((fb_off<<2)+3)>>0] = 255;  // a
    }

    function line(crs, cis, cr_inc, ci_inc, fb_off, fb_inc, n) {
        crs = +crs;
        cis = +cis;
        cr_inc = +cr_inc;
        ci_inc = +ci_inc;
        fb_off = fb_off|0;
        fb_inc = fb_inc|0;
        n = n|0;

        var cr=0.0, ci=0.0, i=0, memb=0;
        cr = crs;
        ci = cis;
        for (i=0; i>>0 < n>>0; i = (i>>0) + 1>>0) {
            memb = ~~(+member(cr,ci) * 255.0);
            heapb[((fb_off<<2)+0)>>0] = 255-memb; // r
            heapb[((fb_off<<2)+1)>>0] = memb; // g
            heapb[((fb_off<<2)+2)>>0] = memb; // b
            heapb[((fb_off<<2)+3)>>0] = 255;  // a

            cr = +cr + +cr_inc;
            ci = +ci + +ci_inc;
            fb_off = (fb_off|0) + (fb_inc|0) |0;
        }
    }

    return { member: member, line: line };
}


function Mandel(canvas_el) {
    this.canvas = canvas_el;
    this.context = this.canvas.getContext('2d');
    this.center = { r:.0001, i:.0001 };
}
Mandel.prototype.resize = function(max_x, max_y) {
    var ratio = window.devicePixelRatio || 1;
    this.size = Math.min(Math.floor(max_x/3),
                         Math.floor(max_y/2));
    this.canvas.style.width  = this.size*3 + "px";
    this.canvas.style.height = this.size*2 + "px";
    this.canvas.width  = this.size*3 * ratio;
    this.canvas.height = this.size*2 * ratio;
    this.context.scale(ratio, ratio);
    this.linebuffer = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
    for (var asm_js_size=4096; asm_js_size < (1<<30) && asm_js_size < this.linebuffer.data.length; asm_js_size *= 2)
        ;
    this.linebuf8  = new ArrayBuffer(asm_js_size);
    this.fast = Mandelbrot(window, {}, this.linebuf8);
    if (!this.pix__coord)
        this.pix__coord = this.canvas.width/2.2;
    this.setup_coords();
}
Mandel.prototype.setup_coords = function() {
    this.r = { min: this.center.r - .5 * this.canvas.clientWidth / this.pix__coord,
               max: this.center.r + .5 * this.canvas.clientWidth / this.pix__coord };
    this.r.span = this.r.max - this.r.min;

    this.i = { min: this.center.i - .5 * this.canvas.clientHeight / this.pix__coord,
               max: this.center.i + .5 * this.canvas.clientHeight / this.pix__coord };
    this.i.span = this.i.max - this.i.min;
}
Mandel.prototype.zoom = function(center, x) {
    this.center = center;
    this.pix__coord *= x;
    this.setup_coords();
}
Mandel.prototype.distance_from_pixels = function(pixel) {
    return { r: pixel.x / this.pix__coord,
             i: pixel.y / this.pix__coord }
}
Mandel.prototype.coords_from_pixels = function(pixel) {
    var distance = this.distance_from_pixels(pixel);
    console.log("distance", distance);
    return { r: this.r.min + distance.r,
             i: this.i.max - distance.i /* pixel (0,0) is top left */}
}
Mandel.prototype.line = function(y) {
    this.fast.line(this.r.min,
                   y/this.canvas.height * this.i.span + this.i.min,
                   this.r.span / this.canvas.width, 0,
                   this.canvas.width * y, 1,
                   this.canvas.width);
}

Mandel.prototype.blit = function() {
    this.linebuffer.data.set(new Uint8Array(this.linebuf8, 0, this.linebuffer.data.length));
    this.context.putImageData(this.linebuffer, 0, 0);
}

Mandel.prototype.draw = function() {
    if (this.drawer)
        clearTimeout(this.drawer);
    this.start = Date.now();
    var y = 0;
    var iter = function() {
        var start = Date.now();
        do {
            this.line(y);
            y++;
        } while (y < this.canvas.height && Date.now() - start < 100);
        this.blit();
        if (y < this.canvas.height)
            this.drawer = setTimeout(iter, 0);
        else {
            console.log(Date.now() - this.start);
        }
    }.bind(this);
    iter();
}
</script>

<script id="mandelbrot-webgl" type="text/javascript">

function MandelGL(canvas) {
    this.canvas = canvas;
    for (var name in { "webgl":0, "experimental-webgl":0, "webkit-3d":0, "moz-webgl":0 })
        try {
            this.gl = this.canvas.getContext(name);
            if (this.gl) break;
        } catch(e) {};
    if (!this.gl)
        return null; // Not supported in this browser.
    this.center = { r:-.5001, i:.0001 };
}
MandelGL.prototype.setup_coords = Mandel.prototype.setup_coords;
MandelGL.prototype.distance_from_pixels = Mandel.prototype.distance_from_pixels;
MandelGL.prototype.coords_from_pixels = Mandel.prototype.coords_from_pixels;
MandelGL.prototype.zoom = function(center, x) {
    this.center = center;
    this.pix__coord *= x;
    this.setup_coords();
    this.draw();
}

MandelGL.prototype.resize = function(max_x, max_y) {
    var ratio = window.devicePixelRatio || 1;
    this.size = Math.min(Math.floor(max_x/3),
                         Math.floor(max_y/2));
    this.canvas.style.width  = this.size*3 + "px";
    this.canvas.style.height = this.size*2 + "px";
    this.canvas.width  = this.size*3 * ratio;
    this.canvas.height = this.size*2 * ratio;

    if (!this.pix__coord)
        this.pix__coord = this.canvas.clientWidth/4;
    this.setup_coords();

    this.configure()
}

MandelGL.prototype.configure = function() {
    var gl = this.gl, canvas = this.canvas;

    gl.viewport(0,0, canvas.width,canvas.height);
    gl.clearColor(0.0, 0.0, 0.3, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

    var next_texture_unit=0;
    var powers_of_2 = {1:1, 2:1, 4:1, 8:1, 16:1, 32:1, 64:1, 128:1, 256:1, 512:1, 1024:1, 2048:1, 4096:1, 8192:1};

    var new_texture = function(width, height, format, data) {
        if (!powers_of_2[width]) throw("Not a power of two: "+width);
        if (!powers_of_2[height]) throw("Not a power of two: "+height);
        var texture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0 + next_texture_unit);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, gl.UNSIGNED_BYTE, data || null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        //gl.generateMipmap(gl.TEXTURE_2D);
        return { texture: texture, tex_unit: next_texture_unit++, format: format, geometry: { width:width, height:height } };
    }

    var data_texture = function(length /*power of 2!*/, height) {
        if (!height) height = 1;
        return new_texture(length/height, height, gl.LUMINANCE);
    }
    var set_texture_data = function(texture, data) {
        gl.activeTexture(gl.TEXTURE0 + texture.tex_unit);
        var byte_data = new Uint8Array(texture.geometry.width * texture.geometry.height);
        byte_data.set(data);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, texture.geometry.width, texture.geometry.height, texture.format, gl.UNSIGNED_BYTE, byte_data);
    }

    var color_table_texture = function(colors) {
        return new_texture(colors.length/3, 1, gl.RGB, new Uint8Array(colors));
    }

    var colors = [];
    for (var i=0; i<256; i++) {
        colors[i*3+0] = 255-i; // r
        colors[i*3+1] = i & 2 ? i : 255-i; // g
        colors[i*3+2] = i; // b
    }

    var color_texture = color_table_texture(colors);

    var squareVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);
    var vertices = [   -10,   -10, 0,
                       +10,   -10, 0,
                       -10,   +10, 0,
                       +10,   +10, 0
                   ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    gl_program(gl, {
        shaders:    { "#mandelbrot-fragment-shader"  : gl.FRAGMENT_SHADER,
                      "#boring-matrix-vertex-shader" : gl.VERTEX_SHADER },
        uniforms:   ['p_matrix', 'mv_matrix', 'r', 'i'],
        attributes: ['vertex_position'],
        init:       { color_table: color_texture.tex_unit },
        callback:
           function(program, error) {
               if (error) return console.log("Errors in 1st pass!\n", error);
               var first_pass = this.first_pass = program;

               gl.enableVertexAttribArray(first_pass.vertex_position);
               gl.vertexAttribPointer(first_pass.vertex_position, 3, gl.FLOAT, false, 0, 0);

               set_uniform_matrix(gl, first_pass.uniform.p_matrix, Matrix.I(4));
           }.bind(this)
    });
}

MandelGL.prototype.draw = function() {
    var start = Date.now();
    var gl = this.gl, first_pass = this.first_pass;

    if (!first_pass) return; // Shaders not initialized yet.

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.useProgram(first_pass.program);

    set_uniform_matrix(gl, first_pass.uniform.mv_matrix, makeOrtho(this.r.min, this.r.max, this.i.min, this.i.max, -1000, 1000));

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.finish();
    console.log(Date.now() - start);
}

    </script>

    <script id="webgl-utils" type="text/javascript">

function compile_shader(gl, type, source, f) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        f(undefined, gl.getShaderInfoLog(shader));
    else
        f(shader);
}

function load_shader(gl, type, url, f) {
    if (url.match(/^#.*$/)) {
        var el = document.getElementById(url.substr(1));
        if (!el)
            return f(undefined, "No element found with id="+url.substr(1));
        compile_shader(gl, type, el.textContent, f);
    } else
        loadText(url, function(shader_source, error, status) {
            if (error) return f(undefined, error, status);
            compile_shader(gl, type, shader_source, f);
        });
}

function load_fragment_shader(gl, url, f) { return load_shader(gl, gl.FRAGMENT_SHADER, url, f) }
function load_vertex_shader(gl, url, f)   { return load_shader(gl, gl.VERTEX_SHADER,   url, f) }

function gl_program(gl, params) {
    var compiled_shaders = [];
    var load_next_shader = function() {
        for (var name in params.shaders)
            break;
        if (name) {
            var type = params.shaders[name];
            delete params.shaders[name];
            load_shader(gl, type, name, function(compiled, error, status) {
                if (error) return params.callback(undefined, name + ": " + (error || "unknown"));
                compiled_shaders.push(compiled);
                load_next_shader();
            });
        } else {
            // All shaders compiled. Time to link.
            var program = { program:   gl.createProgram(),
                            uniform:   {},
                            attribute: {} };
            for (var s in compiled_shaders)
                gl.attachShader(program.program, compiled_shaders[s]);
            gl.linkProgram(program.program);

            if (!gl.getProgramParameter(program.program, gl.LINK_STATUS))
                return params.callback(undefined, "Shader program failed link stage");

            gl.useProgram(program.program);

            for (var u=0; u<params.uniforms.length; u++)
                program.uniform[params.uniforms[u]]  = gl.getUniformLocation(program.program, params.uniforms[u]);
            for (var a=0; a<params.attributes.length; a++)
                program.attribute[params.attributes[a]]  = gl.getAttribLocation(program.program, params.attributes[a]);
            for (var name in params.init)
                gl.uniform1i(gl.getUniformLocation(program.program, name), params.init[name]);

            params.callback(program);

            // for (var i=0; ; i++) {
            //     var u = gl.getActiveUniform(program, i);
            //     if (!u) break;
            //     console.log("%d: %s %d %d\n", i, u.name, u.type, u.size);
            // }

        }
    }
    load_next_shader();
}

function set_uniform_matrix(gl, uniform, matrix) {
    gl.uniformMatrix4fv(uniform, false, new Float32Array(matrix.flatten()));
}


    </script>

    <script id="sylvester-minimal" type="text/javascript">
function Matrix() {}
Matrix.prototype = {

  setElements: function(els) {
    var i, elements = els.elements || els;
    if (typeof(elements[0][0]) != 'undefined') {
      var ni = elements.length, ki = ni, nj, kj, j;
      this.elements = [];
      do { i = ki - ni;
        nj = elements[i].length; kj = nj;
        this.elements[i] = [];
        do { j = kj - nj;
          this.elements[i][j] = elements[i][j];
        } while (--nj);
      } while(--ni);
      return this;
    }
    var n = elements.length, k = n;
    this.elements = [];
    do { i = k - n;
      this.elements.push([elements[i]]);
    } while (--n);
    return this;
  }
};

// Constructor function
Matrix.create = function(elements) {
  var M = new Matrix();
  return M.setElements(elements);
};

// Identity matrix of size n
Matrix.I = function(n) {
  var els = [], k = n, i, nj, j;
  do { i = k - n;
    els[i] = []; nj = k;
    do { j = k - nj;
      els[i][j] = (i == j) ? 1 : 0;
    } while (--nj);
  } while (--n);
  return Matrix.create(els);
};

// Utility functions
var $M = Matrix.create;
    </script>


    <script id="glUtils" type="text/javascript">
Matrix.prototype.flatten = function ()
{
    var result = [];
    if (this.elements.length == 0)
        return [];


    for (var j = 0; j < this.elements[0].length; j++)
        for (var i = 0; i < this.elements.length; i++)
            result.push(this.elements[i][j]);
    return result;
}

//
// glOrtho
//
function makeOrtho(left, right,
                   bottom, top,
                   znear, zfar)
{
    var tx = -(right+left)/(right-left);
    var ty = -(top+bottom)/(top-bottom);
    var tz = -(zfar+znear)/(zfar-znear);

    return $M([[2/(right-left), 0, 0, tx],
               [0, 2/(top-bottom), 0, ty],
               [0, 0, -2/(zfar-znear), tz],
               [0, 0, 0, 1]]);
}
    </script>


    <script id="main" type="text/javascript">
var mandel = new MandelGL(document.getElementById("mandelbrot"));
window.onresize = function() {
    var sizer = document.getElementById("mandelbrot-size");
    mandel.resize(sizer.clientWidth,
                  sizer.clientHeight);
    mandel.draw();
}
window.onresize();

mandel.canvas.ondblclick = function(event) {
    var center = mandel.coords_from_pixels({ x: event.clientX, y: event.clientY });
    mandel.zoom(center, 3);
};

mandel.canvas.ontouchstart = mandel.canvas.onmousedown = function(event) {
    var start = { pix: { x: event.clientX, y: event.clientY },
                  center: mandel.center };
    mandel.canvas.ontouchmove = mandel.canvas.onmousemove = function(event) {
        var distance = mandel.distance_from_pixels({x: start.pix.x-event.clientX,
                                                    y: event.clientY-start.pix.y});
        mandel.zoom({ r: start.center.r + distance.r,
                      i: start.center.i + distance.i },
                    1);
    }
    mandel.canvas.ontouchend = mandel.canvas.onmouseup = function(event) {
        mandel.canvas.onmouseup = mandel.canvas.onmousemove = void 0;
    }
}

mandel.canvas.onwheel = function(event) {
    mandel.zoom(mandel.center, Math.pow(2, event.deltaY/mandel.canvas.clientHeight));
    event.preventDefault();
}

    </script>

  <address>
    <a href="mailto:david@porkrind.org">David Caldwell</a>
  </address>
  </body>
</html>